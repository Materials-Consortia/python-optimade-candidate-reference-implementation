(* BEGIN EBNF GRAMMAR Filter *)
(* The top-level 'filter' rule: *)

Filter = Expression ;

(* Values *)

Value = String | Number | Identifier ;
(* Note: support for Identifier in Value is OPTIONAL *)

ValueList = Value, {',', Value } ;

ValueZip = Value, ':', Value, {':', Value} ;

ValueZipList = ValueZip, { ',', ValueZip } ;

(* White-space: *)

Space = ' ' | '\t' ;

(* Boolean relations: *)

AND = "AND" ; (* a short-hand for: AND = 'A', 'N', 'D' *)
NOT = "NOT" ;
OR = "OR" ;
KNOWN = "KNOWN" ;
UNKNOWN = "UNKNOWN" ;
IS = "IS" ;
CONTAINS = "CONTAINS" ;
STARTS = "STARTS" ;
ENDS = "ENDS" ;
LENGTH = "LENGTH" ;
HAS = "HAS" ;
ALL = "ALL" ;
ONLY = "ONLY" ;
EXACTLY = "EXACTLY" ;
ANY = "ANY" ;

(* Expressions *)

Expression = ExpressionClause, [ OR, Expression ] ;

ExpressionClause = ExpressionPhrase, [ AND, ExpressionClause ] ;

ExpressionPhrase = [ NOT ], ( Comparison | PredicateComparison | '(', Expression, ')' );

(* OperatorComparison operator tokens: *)

Operator = '<', [ '=' ] | '>', [ '=' ] | '=' | '!', '=' ;

Comparison = Identifier, ( 
                ValueOpRhs |
                KnownOpRhs |
                FuzzyStringOpRhs |
                SetOpRhs | 
                SetZipOpRhs );
(* Note: support for SetZipOpRhs in Comparison is OPTIONAL *)

PredicateComparison = LengthComparison ;

ValueOpRhs = Operator, Value ;

KnownOpRhs = IS, ( KNOWN | UNKNOWN );  

FuzzyStringOpRhs = CONTAINS, String | STARTS, String | ENDS, String ;

SetOpRhs = HAS, ( Value | ALL, ValueList | EXACTLY, ValueList | ANY, ValueList | ONLY, ValueList );
(* Note: support for ONLY in SetOpRhs is OPTIONAL *)

SetZipOpRhs = IdentifierZipAddon, HAS, ( ValueZip | ONLY, ValueZipList | ALL, ValueZipList | EXACTLY, ValueZipList | ANY, ValueZipList ) ;

LengthComparison = LENGTH, Identifier, Operator, Value ;

IdentifierZipAddon = ':', Identifier, {':', Identifier} ;

(* Identifier syntax *)

Identifier = Letter, { Letter | Digit } ;

Letter =
    'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' |
    'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' |
    'Y' | 'Z' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' |
    'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' |
    'w' | 'x' | 'y' | 'z' | '_'
;

(* Strings: *)

String = '"', { EscapedChar }, '"' ;

EscapedChar = UnescapedChar | '\', '"' | '\', '\' ;

UnescapedChar = Letter | Digit | Space | Punctuator | UnicodeHighChar ;

Punctuator =
    '!' | '#' | '$' | '%' | '&' | "'" | '(' | ')' | '*' | '+' | ',' | 
    '-' | '.' | '/' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | '[' |
    ']' | '^' | '`' | '{' | '|' | '}' | '~'
;

(* The 'UnicodeHighChar' specifies all Unicode characters above 0x7F;
   the syntax used is the onw compatible with Grammatica: *)

UnicodeHighChar = ? [^\x00-\xFF] ? ;
 
(* BEGIN EBNF GRAMMAR Number *)
(* Number token syntax: *)

Number = [ Sign ] ,
         ( Digits, [ '.', [ Digits ] ] | '.' , Digits ),
         [ Exponent ] ;

Exponent =  ( 'e' | 'E' ) , [ Sign ] , Digits ;

Sign = '+' | '-' ;

Digits =  Digit, { Digit } ;

Digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;

(* END EBNF GRAMMAR Number *)
(* END EBNF GRAMMAR Filter *)
